//~ Copyright (C) 2014-2017: Willem Vree, contributions St√©phane David.
//~ This program is free software; you can redistribute it and/or modify it under the terms of the
//~ GNU General Public License as published by the Free Software Foundation; either version 2 of
//~ the License, or (at your option) any later version.
//~ This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
//~ without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//~ See the GNU General Public License for more details. <http://www.gnu.org/licenses/gpl.html>.

//~ "use strict";
var msc_VERSION = 42;

var opt, onYouTubeIframeAPIReady, msc_credits, media_height, times_arr, offset_js, endtime_js, abc_arr, lpRec;
(function () {
var muziek, curmtr, curtmp, msc_svgs, msc_gs, msc_wz, offset, mediaFnm, abcSave, elmed, scoreFnm, timerId = -1;
var ybplayer, yubchk = 0, pbrates = [], noprogress = 0, onYouTubeAPIContinue, opt_url = {}, sok = null, gFac;
var dummyPlayer = new DummyPlayer (), TOFF = 0.01;
opt = {}; // global options
onYouTubeIframeAPIReady = yubApiReady;

function initPreload () {
    opt = {'jump':0, 'no_menu':0, 'repufld':0, 'noplyr':0, 'nocsr':0, 'media_height':'', 'btns':1, 'ipadr':'',
        'mstr':0, 'autscl':0, 'ctrmed':0, 'ctrnot':0, 'lncsr':0, 'opacity':0.2, 'synbox':0, 'speed':1.0, 'top_margin':0,
        'yubvid':'', 'nomed':0, 'delay':0, 'repskip':0, 'spdctl':0, 'lopctl':0, 'metro':0 }
    $('#yubuse').prop ('checked', false);
    $('#yvdlbl, #vidyub').css ('display', 'none');
    msc_credits = undefined; $('#credits').html ('');
    media_height = undefined;           // backwards compatibility (reset from previous preload)
    $('#buttons').css ('height','');    // remove explicit height from previous preload
    mediaFnm = '';
    yubchk = 0;
    elmed = null;
}
function initGlobals () {
    abcSave = '';       // abc code:: [string]
    muziek = '';        // svg code generated by abc2svg
    curmtr = [0,0,0];   // current metre
    curtmp = [0,0,0];   // current tempo
    msc_svgs = []       // svg elements, one per line of music
    msc_gs = []         // top graphics elements <g></g> of all music lines
    msc_wz = null;      // gobal cursor object
    offset = 0.0;       // offset: time in media file where music starts
    gFac = 0.1;         // absolute change for offset or duration
    noprogress = 0;     // stop cursor until offset synced
}

function Wijzer (xss, ymins, ymaxs, times, tixlb, lbtix, tixbts) {  // create the music cursor
    this.xs = xss;          // [[x coor of barlines] for each line]
    this.ymin = ymins;      // [y coor of top staff for each line]
    this.ymax = ymaxs;      // idem bottom staff
    this.times = times;     // [[music time at barlines] for each line]
    this.times.unshift (0); // add a starting time of zero
    this.tixbts = tixbts;   // remember beats per played measure
    this.line = 0;          // current music line index
    this.msre = 1;          // current measure index
    this.width = 0;         // width of svg music line
    this.wijzer = $(document.createElementNS ('http://www.w3.org/2000/svg','svg'));
    this.wijzer.attr ('id', 'wijzer');
    this.wijzer.css ('overflow','visible');
    this.shade = $(document.createElementNS ('http://www.w3.org/2000/svg','rect'));
    this.shade.attr ({width:'100%', height:'100%'});
    this.wijzer.append (this.shade);
    this.tiktak = $(document.createElementNS ('http://www.w3.org/2000/svg','text'));
    this.tiktak.attr ('y', 5);
    this.tiktak.css ({fill:'green', stroke:'green', 'text-anchor':'end', 'font-size':'xx-large'});
    this.wijzer.append (this.tiktak);
    this.atag =  $(document.createElementNS ('http://www.w3.org/2000/svg','text'));
    this.atag.attr ('id', 'atag'); this.atag.text ('<');
    this.atag.css ({fill:'red', stroke:'red', 'text-anchor':'middle'});
    this.btag =  $(document.createElementNS ('http://www.w3.org/2000/svg','text'));
    this.btag.attr ('id', 'btag'); this.btag.text ('>');
    this.btag.css ({fill:'red', stroke:'red', 'text-anchor':'middle'});
    if (typeof (lpRec) == 'undefined') {    // skip if defined in preload
        lpRec = { loopBtn: 1, loopStart: 0, loopEnd: times [times.length - 1] } // end of music
        $ ('#lopctl').prop ('checked', false);  // clear option and menu item
        opt.lopctl = 0;
    }
    this.hmargin = 100;     // horizontal scroll margin
    this.vmargin = 50;      // vertical scroll margin
    this.tmargin = opt.top_margin >= 0 ? opt.top_margin : this.vmargin; // margin bewteen media and score
    this.lastSync = 0;      // last measure that was synced.
    this.setScale ();       // offsets of music lines (w.r.t. top notation area) and scale factor (g-coors -> pixels)
    this.cursorTime = 0;    // time position of cursor for redraw when no media loaded
    this.time_ix = 1;       // points to end time of first measure in this.times
    this.tixlb = tixlb;     // time index -> [line_num, bar_index, repcnt]
    this.lbtix = lbtix;     // line_num, bar_index, repcnt -> time index
    this.repcnt = 1;        // current repeat count
    this.noCursor = 0;      // hide cursor
}
Wijzer.prototype.setline = function (line) {
    $('#wijzer').remove (); // take away cursor from where it was
    this.sety (this.ymin [line], this.ymax [line]);
    this.setx (0, 0, 0);    // hide cursor at start
    this.line = line;
    this.wijzer.prependTo (msc_gs [line]);  // insert cursor in target music line
    this.width = msc_svgs [line].width.baseVal.value;
    var n = $('#notation'), ntop = n.scrollTop ();
    var ymx = ntop + n.height () - this.vmargin;    // bottom of notation area
    if (this.line_offsets [line + 1] > ymx || this.line_offsets [line] < ntop + this.vmargin) {
        n.scrollTop (this.line_offsets [line] - this.tmargin);
    }
}
Wijzer.prototype.sety = function (ymin, ymax) {    // set height, width and top y-coor of music cursor
    this.wijzer.attr ('y', ymin.toFixed (2));
    this.wijzer.attr ('width','2');
    this.wijzer.attr ('height', (30 + ymax - ymin).toFixed (2));
    this.shade.attr ('fill','blue');
}
Wijzer.prototype.setx = function (x, xleft, xright) { // horizontal position in music line
    var n = $('#notation'), nleft = n.scrollLeft ();
    var xmx = nleft + n.width () - this.hmargin; // right most side of notation area
    if (opt.lncsr) {
        this.wijzer.attr ('x', x.toFixed (2));
        this.wijzer.attr ('width', '2');
        this.shade.attr ('fill-opacity', this.noCursor ? '0.0' : '0.5');
        x = x / this.scale;                     // g-coors -> pixels for scroll test
        if (x > xmx || x < nleft + this.hmargin) {
            n.scrollLeft (x - this.hmargin);
        }
    } else {
        this.wijzer.attr ('x', xleft.toFixed (2));
        this.wijzer.attr ('width', (xright - xleft).toFixed (2));
        this.shade.attr ('fill-opacity', this.noCursor ? '0.0' : '' + opt.opacity);
        xleft = xleft / this.scale;             // g-coors -> pixels for scroll test
        xright = xright / this.scale;
        if (xright > xmx || xleft < nleft + this.hmargin) {
            n.scrollLeft (xleft - this.hmargin);
        }
    }
}
Wijzer.prototype.time2x = function (t, rondaf) {
    if (noprogress) return; // stop cursor until offset synced
    this.cursorTime = t;
    var times, line, ts, xs, msre, tix;
    times = this.times;
    tix = this.time_ix;
    while (tix < times.length && t > times [tix]) tix += 1;
    if (tix == times.length) {  // music duration exceeds score duration -> pause
        if (yubchk) { if (elmed.getPlayerState() == 1) elmed.pauseVideo (); }
        else        { if (!elmed.paused) elmed.pause (); }
        return;
    }
    while (tix > 0 && t < times [tix - 1]) tix -= 1;
    if (rondaf && times [tix] - t < 0.3) {      // and times [tix] - t >= 0, by while loop above
        times [tix] = t - TOFF;                 // correct timing !!
        console.log ('tijdcor: ' + (t - TOFF) + ', maat: ' + tix);
        if (tix < times.length - 1) tix += 1;   // t now in the next measure
    }
    if (opt.metro && tix != this.time_ix) metronome (tix, t);
    this.time_ix = tix;
    this.repcnt = this.tixlb [tix][2];
    msre = this.tixlb [tix][1], this.msre = msre;
    line = this.tixlb [tix][0]
    if (this.line != line) { this.setline (line); }

    var tleft, tright, xleft, xright, x, lastTime;
    var xs = this.xs [line];
    tleft = times [tix - 1]; tright = times [tix];
    xleft = xs [msre - 1] + 10; xright = xs [msre] + 10;  // x positions are from box outlines, add 10 to appox. real position
    x = xleft + (xright - xleft) * (t  - tleft) / (tright - tleft);
    lastTime = this.times [this.times.length - 1];
    if (t <= 0 || t > lastTime) this.setx (0, 0, 0);   // hide cursor if t not within score
    else                        this.setx (x, xleft, xright);
    if (opt.synbox) { this.showSyncInfo (); }
}
Wijzer.prototype.drawTags = function () {
    for (var k in {atag:1, btag:1}) {
        if (!(k in lpRec)) continue;
        a = lpRec [k];
        this [k].prependTo (msc_gs [a.line]);
        this [k].attr ('x', a.x);
        this [k].attr ('y', this.ymin [a.line]);
    }
}
Wijzer.prototype.doLoopTag = function (x, line, t, ix, tix) {
    function putTag (tag, x, line, next, mark, t, ix, tix) {
        if (!opt.lncsr) {   // round click position to start or end of measure
            var xs = that.xs [line], ts = that.times;
            var xleft = xs [ix - 1],  xright = xs [ix];
            var tleft = ts [tix - 1], tright = ts [tix];
            if (lpRec.loopStart == tleft + TOFF) { tag = 'btag'; mark = 'loopEnd'; } // when mark already there put the other one
            if (lpRec.loopEnd == tright - TOFF)  { tag = 'atag'; mark = 'loopStart'; }
            if (mark == 'loopStart') { x = xleft; t = tleft + TOFF; }
            else { x = xright; t = tright - TOFF; }
        }
        lpRec [tag] = { x: x.toFixed (2), line: line };
        lpRec.loopBtn = next;
        lpRec [mark] = t;
        that.drawTags ();
    }
    var d1, d2, that = this;
    switch (lpRec.loopBtn) {
    case 1: putTag ('atag', x, line, 2, 'loopStart', t, ix, tix); break;
    case 2: if (t > lpRec.loopStart) putTag ('btag', x, line, 3, 'loopEnd', t, ix, tix); break;
    case 3:                         // reposition mark closest to time of click location
        d1 = Math.abs (lpRec.loopStart - t);
        d2 = Math.abs (lpRec.loopEnd - t);
        if (d1 < d2) putTag ('atag', x, line, 3, 'loopStart', t, ix, tix);
        else         putTag ('btag', x, line, 3, 'loopEnd', t, ix, tix);
    }
}
Wijzer.prototype.x2time = function (x, line) {
    var xs, ts, ix, xleft, xright, tleft, tright, t, tix;
    x = x * this.scale;
    xs = this.xs [line];
    ix = 1;
    if (x < xs [0]) { keyDown ({'keyCode':80}); return; }       // position before first bar line
    while (ix < xs.length && xs [ix] < x) ix += 1;
    if (ix == xs.length) { keyDown ({'keyCode':80}); return; }  // position beyond last bar line
    var msretix = this.lbtix [line][ix];
    if (!msretix [this.repcnt]) this.repcnt = 1;                // clicked outside repeat: reset repcnt
    tix = msretix [this.repcnt];                                // ix == bar number == 1..
    ts = this.times;
    xleft = xs [ix - 1];  xright = xs [ix];
    tleft = ts [tix - 1]; tright = ts [tix];
    t = tleft + (tright - tleft) * (x - xleft) / (xright - xleft);
    if (opt.lopctl) { this.doLoopTag (x, line, t, ix, tix);
    } else {
        if (opt.synbox && (yubchk ? elmed.getPlayerState () == YT.PlayerState.PLAYING : !elmed.paused)) {
            this.syncTimes (x, ix, line, tix);
        } else playPause2 (false, (opt.lncsr ? t : tleft + TOFF) + offset);  // do not toggle player state
    }
}
Wijzer.prototype.goMsre = function (b) {    // one measure forwards (1) or backwards (0)
    var t, tix = this.time_ix;
    if (!elmed) return;
    if (b) t = this.times [tix] + TOFF;     // go just beyond end of current measure
    else {
        if (tix <= 2)   t = TOFF;
        else            t = this.times [tix - 2] + TOFF;    // tix - 2 >= 1
    }
    playPause2 (false, t + offset);         // do not toggle player state
}
Wijzer.prototype.showSyncInfo = function () {
    var tix = this.time_ix;
    var msre_dur = this.times [tix] - this.times [tix - 1];
    $('#sync_info').html ('duration&nbsp;measure:<br>' + msre_dur.toFixed (3) + ' sec.<br>');
    $('#sync_info').append ('media&nbsp;offset:<br>' + offset.toFixed (3) + ' sec.');
}
Wijzer.prototype.changeTimesKeyb  = function (gfac) {
    var mnum = this.lbtix [this.line] [this.msre][this.repcnt] - 1; // the cursor is in measure mnum = tix - 1 = 0..
    this.changeTimes (mnum, gfac, 0);
}
Wijzer.prototype.changeTimes = function (mnum, dt, dur) {   // endtime += dt or endtime = begintime + dur
    var tix, tendnew, ts = this.times;
    for (tix = mnum + 1; tix < ts.length; ++ tix) {
        tendnew = dur ? ts [tix - 1] + dur : ts [tix] + dt; // ts [tix-1] == begintime
        ts [tix] = tendnew;
    }
}
Wijzer.prototype.syncTimes = function (x, ix, line, tix) {  // click location, measure index, line number, time index
    var mnum, tbeg, tend, t, tleft;
    mnum = this.lbtix [line][ix][this.repcnt] - 1;          // mnum = 0..
    t = (yubchk ? elmed.getCurrentTime () : elmed.currentTime) - offset - 0.2;   // subtract a constant delay to compensate processing time
    tleft = t;
    if (mnum == 0) {            // click in first measure sets the offset
        offset += tleft;        // approximated new begin time -> offset
        yubchk ? elmed.seekTo (offset + TOFF, true) : elmed.currentTime = offset + TOFF;  // jump to start
        if (noprogress) $('#woff').click ();    // cursor starts moving again
        return;
    }   // mnum >= 1, tix >= 2
    mnum -= 1;                  // change end time or duration of previous measure
    tbeg = tix == 2 ? 0 : this.times [tix - 2];
    tend = this.times [tix - 1];
    if (tleft < tbeg + 0.5) {   // 0.5 sec, beats per measure > 2 -> tempo > 240
        alert ('tempo faster than 240 bpm: first sync previous measures'); return }
    if (this.lastSync > mnum) { // only change duration of mnum and keep the rest unchanged
        this.changeTimes (mnum, tleft - tend, 0);
    } else {                    // change duration of all measures >= mnum (extrapolate current tempo)
        this.changeTimes (mnum, 0, tleft - tbeg);
        this.lastSync = mnum;
    }
    if (opt.jump) {
        yubchk ? elmed.seekTo (tbeg + offset + TOFF, true) : elmed.currentTime = tbeg + offset + TOFF;  // jump to start of previous measure
    }
}
Wijzer.prototype.setSize = function () {
    var i, svg, w_svg, h_svg, new_w;
    for (i = 0; i < msc_svgs.length; ++i) {
        svg = msc_svgs[i]
        w_svg = svg.width.baseVal.value;
        h_svg = svg.height.baseVal.value;
        new_w = $('#notation').prop ('clientWidth');
        svg.width.baseVal.value = new_w;
        svg.height.baseVal.value = new_w * h_svg / w_svg;
    }
}
Wijzer.prototype.setScale = function () {
    var i, x, w_svg, w_vbx, scale, divoff, divscroll, m, svg = msc_svgs[0];    
    w_svg = svg.getBoundingClientRect ().width;     // width svg element in pixels
    w_vbx = svg.viewBox.baseVal.width;              // width svg element (vbx coors)
    m = $('svg>g').get (0).transform.baseVal;       // scale factor top g-grafic
    scale = m.length ? m.getItem (0).matrix.a : 1;  // scale: svg-coors -> vbx-coors
    this.scale = ((w_vbx / scale) / w_svg);         // pixels -> svg-coors
    divoff = $('#notation').position ();        // music area relative to offset parent
    divscroll = $('#notation').scrollTop ();
    this.line_offsets = [];                     // [(top music line - top music area) for each line]
    for (var i = 0; i < msc_svgs.length; ++i) {
        x = $(msc_svgs [i]).position ();
        this.line_offsets [i] = divscroll + x.top - divoff.top;
    }
    this.line_offsets [i] = $('#notation').prop ('scrollHeight');   // next line would start here
}

Wijzer.prototype.compCountIn = function () {
    var count_in = {time: 0.25, num: 4};             // default for piece with one measure
    var b = this.time_ix > 1 ? this.time_ix - 1 : this.time_ix; // start at current measure but skip the very first
    var e = Math.min (this.times.length - 1, b + 3); // tempo is avarage of next three measures
    if (e > b) {
        var totbeats = this.tixbts.slice (b, e).reduce (function (x, y) { return x + y; }, 0)
        count_in.time = (this.times [e] - this.times [b]) / totbeats / opt.speed;
        count_in.num = this.tixbts [b];
    }
    return count_in;
}

function DummyPlayer () {
    this.paused = true;
    this.currentTime = 0;
    this.klok = -1;
    this.step = 200;
    this.playing = 0;
    initPbRates (0.1, 4, 0.05);
}
DummyPlayer.prototype.pause = function () {
    this.clearKlok ();
    tick ();
}
DummyPlayer.prototype.play = function () {
    this.paused = false;
    if (this.klok != -1) return;  // play after play (when changing currentTime)
    var o = this;
    this.setKlok (function () {
        o.currentTime += (o.step / 1000) * opt.speed;
        tick ();
    }, this.step);
}
DummyPlayer.prototype.setKlok = function (f, dt) {
    if (this.klok != -1) clearInterval (this.klok);
    this.klok = f ? setInterval (f, dt) : -1;   // setInterval () > 0
    this.paused = false;
    if (msc_wz && opt.nocsr) msc_wz.noCursor = 1;
}
DummyPlayer.prototype.clearKlok = function () {
    if (this.klok != -1) clearInterval (this.klok);
    this.klok = -1;
    this.paused = true;
    if (msc_wz) msc_wz.noCursor = 0;
}

function toggleScoreBtn () {
    var b = $('#abclbl'), h = b.html (), c = $('#impbox').prop ('checked');
    b.toggleClass ('abcimp', c);
    b.html (c ? h.replace ('score file','<b>import</b>') : h.replace ('<b>import</b>','score file'));
    if (c && !opt.btns) $('#btns').click ();    // show file buttons (-> checkMenu -> btnChk etc.)
}

function copyTiming (xs, abctxt) {
    if (xs.indexOf ('//# This page') < 0) { alert ('not a preload file'); return }
    xs = abctxt.replace (/\n/g,'');
    var r = xs.match (/offset_js = (.*);/);
    if (r.length > 1) offset = offset_js =  parseFloat (r[1]);
    var r = xs.match (/times_arr = (.*);abc_arr/);
    if (r.length > 1) times = flattenTimes (JSON.parse (r[1]));
    if (msc_wz) {
        msc_wz.times = times;
        msc_wz.times.unshift (0);
    }
    $('#impbox').prop ('checked', false);
    toggleScoreBtn ();
}

function readAbcOrXML (abctxt) {
    var xs = abctxt.slice (0, 4000);    // only look at the beginning of the file
    if ($('#impbox').prop ('checked')) { copyTiming (xs, abctxt); return; }
    if (xs.indexOf ('//# This page') >= 0) {
        initPreload ();                 // should run before preload file is executed
        eval (abctxt);                  // preload from source file button executes here
        msc_check_preload ();
        return;
    }
    if (xs.indexOf ('X:') >= 0)      { dolayout (abctxt); return }
    if (xs.indexOf ('<?xml ') == -1) { alert ('not an xml file nor an abc file'); return }
    var xmldata = $.parseXML (abctxt);
    var options = { 'p':'f', 't':1, 'u':1?opt.repufld:0, 'v':3 }; // t==1 -> clef determines step value on staff
    var res = vertaal (xmldata, options);
    if (res[1]) $('#err').append (res[1] + '\n');
    dolayout (res[0]);
}

function readDbxFile (files) {
    $('#err').text ('');    // clear error output area
    times_arr = undefined;  // clear possible preload data
    offset_js = undefined;
    lpRec = undefined;
    var url = files[0].link;
    scoreFnm = files[0].name.split ('.')[0];
    $('#wait').toggle (true);
    $('#err').text ('link: ' + url + '\n');
    $.get (url, '', null, 'text').done (function (data, status) {
        $('#err').append ('preload: ' + status + '\n');
        abc_arr = data.split ('\n');
        msc_check_preload ();
    }).fail (function (jqxhr, settings, exception) {    // same origin policy
        $('#wait').append ('\npreload failed: ' + settings);
    });
}

function readLocalFile (type, files) {
    $('#err').text ('');    // clear error output area
    times_arr = undefined;  // clear possible preload data
    offset_js = undefined;
    if (!$('#impbox').prop ('checked')) lpRec = undefined;  // not when we only read the timing data !!
    var freader = new FileReader ();
    freader.onload = function (e) { readAbcOrXML (freader.result); }
    var f = type == 'dd' ? files [0] : $('#fknp').prop ('files')[0];
    if (f) {
        scoreFnm = f.name.split ('.')[0];
        freader.readAsText (f);
    }
}

function doDrop (e) {
    e.stopPropagation (); e.preventDefault ();
    $('body').toggleClass ('indrag', false);
    var files = e.dataTransfer.files;
    if (/video|audio/.test (files [0].type))    // xml => 'text/xml', abc => ''
         readMedia ('dd', files)
    else readLocalFile ('dd', files);
}

function readMedia (type, files) {
    var f, url;
    if (type == 'dbx') {    // dropbox
        f = files[0];
        url = f.link;
    } else {                // type 'btn' or 'dd'
        f = type == 'dd' ? files [0] : $('#mknp').prop ('files')[0];
        url = window.URL.createObjectURL (f);
    }
    setPlayer (f.name, url);    
}

function readMediaYub () {
    if (!$('#yubid')[0].checkValidity()) {
        alert ("The youtube video id should be 11 characters long,\neach from 'A' to 'Z', 'a' to 'z', '0' to '9', '-' or '_'");
        return;
    }
    opt.yubvid = $('#yubid').val ();
    setPlayer ('', '');
}

function initPbRates (min, max, inc) {
    pbrates = [];
    for (var x = min; x <= max + 0.001; x += inc) { // 0.001 because error in javascript integers !!
        x = Math.round (x * 100) / 100;
        pbrates.push (x);
    }
}

function yubApiReady () {
    function klaar () { $('#yubuse').prop ('checked', true); medbtnSwitch (); yubload (); }
    function toestand (evt) {
        if (evt.data == YT.PlayerState.PLAYING) { 
            dummyPlayer.setKlok (tick, 100);
            setSpeed (0);   // only now the player honours the speed setting
        } else dummyPlayer.pause ();
        if (evt.data == YT.PlayerState.CUED) {
            setNotationHeight ();
        }
    }
    ybplayer = new YT.Player ('vidyub', { events: { 'onReady': klaar, 'onStateChange': toestand } });
}

function yubload (f) {
    if (f) onYouTubeAPIContinue = f;
    function grey (b) {
        $('#yubuse').attr ('disabled',b); $('#yublbl').css ('color',b?'#aaa':'#000');
        $('#yubload').toggle (b);
    }
    if (typeof (YT) == 'undefined') {
        grey (true); $('#yubuse').prop ('checked', false);
        $.getScript ("https://www.youtube.com/iframe_api");
    } else {
        grey (false);
        onYouTubeAPIContinue ();
    }
}

function setPlayer (fnm, mediaSrc) {
    mediaSrc = mediaSrc.replace ('www.dropbox', 'dl.dropboxusercontent').split ('?')[0];    // make direct link
    mediaFnm = mediaSrc.indexOf ('http') == 0 ? mediaSrc : fnm; // URL to the dropbox file | local file name
    var $elmed;
    fnm = fnm.split ('?')[0];           // strip url parameter when using dropbox (?dl=1)
    $('#vid, #aud').attr ('src','');    // stop current media
    if (ybplayer) ybplayer.stopVideo ();
    dummyPlayer.clearKlok ();           // stop running Dummy player -> clearInterval
    if (!fnm) {                         // youtube
        yubchk = 1;
        $('#vid, #aud').css ('display','none');
        $('#vidyub').css ('display','inline-block');
        $('#buttons').toggleClass ('video', true);
        yubload (function () {
            elmed = ybplayer;
            pbrates = elmed.getAvailablePlaybackRates ();
            setSpeed (0);
            setNotationHeight ();   // redundant, but with iOS no cued event (after url-preload)
            elmed.cueVideoById ({videoId: opt.yubvid, startSeconds: offset});
        });
    } else {
        yubchk = 0;
        if (/\.webm$|\.mp4$/i.test (fnm)) {
            $elmed = $('#vid');
            if ($elmed.length == 0) return; // video not supported 
            $('#vidyub, #aud').css ('display','none');
            $elmed.css ('display','inline-block');
            $('#buttons').toggleClass ('video', true);
        } else {
            $elmed = $('#aud');
            if ($elmed.length == 0) return; // audio not supported 
            $('#vidyub, #vid').css ('display','none');
            $elmed.css ('display','inline-block');
            $('#buttons').toggleClass ('video', false);
        }
        elmed = $elmed.get (0);
        if (/\.ogg$/i.test (mediaSrc)) {    // may be also mp3 file present
            if (!elmed.canPlayType ('audio/ogg')) mediaSrc = mediaSrc.replace (/\.ogg$/i, '.mp3');
        }
        if (/\.webm$/i.test (mediaSrc)) {
            if (!elmed.canPlayType ('video/webm')) mediaSrc = mediaSrc.replace (/\.webm$/i, '.mp4');
        }
        $elmed.attr ('src', mediaSrc + (offset ? '#t=' + offset : ''));
        $elmed.on ('timeupdate', tick);     // tick updates music cursor
        $elmed.on ('playing', function () {
            dummyPlayer.setKlok (null, 0);
            elmed.playbackRate = opt.speed;
        });
        $elmed.on ('pause', function () { dummyPlayer.pause () });
        $elmed.on ('loadedmetadata', setNotationHeight)
        initPbRates (0.5, 2, 0.05);
        setSpeed (0);
        setNotationHeight ();   // redundant, but with iOS no cued event (after url-preload)
    }
}

function medbtnSwitch () {
    var yb = $('#yubuse').prop ('checked');
    $('#medlbl').css ('display', yb ? 'none' : 'block');
    $('#yvdlbl').css ('display', yb ? 'block' : 'none');
}

function centerPlayer () {
    var ww = parseInt ($('body').css  ('width')) / 2;
    var wv = parseInt ($('#vid').css ('width')) / 2;
    var wy = parseInt ($('#vidyub').css ('width')) / 2;
    var wa = parseInt ($('#aud').css ('width')) / 2;
    $('#vid').css ('margin-left',  opt.ctrmed ? (ww - wv).toFixed () + 'px' : '0px');
    $('#vidyub').css ('margin-left',  opt.ctrmed ? (ww - wy).toFixed () + 'px' : '0px');
    $('#aud').css ('margin-left',  opt.ctrmed ? (ww - wa).toFixed () + 'px' : '0px');
    $('#meddiv').css ('text-align', opt.ctrmed ? 'left' : 'center');
}

function setNotationHeight () {
    if (elmed) $(elmed).toggle (!opt.noplyr);
    $('#buttons').toggleClass ('noheight', !!opt.noplyr);    // !! -> jquery wants real boolean
    var chk = $('#btns').prop ('checked');
    var h = parseFloat ($('#buttons').css ('height'));
    var b = parseFloat ($('body').css ('height'));
    var e = chk ? parseFloat ($('#err').css ('height')) : 0;
    var x = 100 - (100 * (h + e) / b).toFixed ();
    $('#notation').css ('height', x + '%');   // fill all space below media
    $('#vidyub').css ('width', (h * 0.95 * 1.6).toFixed ());   // youtube player needs width, aspect 1.6
    centerPlayer ();
};

function dolayout (abctxt) {
    var muziek = '', errtxt = '', abc2svg, bxs = {}, bys = {}, bars = [], xleft, times = [], nxs = [], mtxts = [];
    var BAR = 0, METER = 6, NOTE = 8, REST = 10, TEMPO = 14, BASE_LEN = 1536, tixbts = [], mbeats = [], mreps = [], mdurs = [];
    var tixlb = [[0,0,1]];          // time index -> [line_num, bar_num, repcnt], line_num == 0.., bar_num == 1.., repcnt = 1..
    var lbtix = [];                 // line_num, bar_num, repcnt -> time index
    function errmsg(txt, line, col) {
        errtxt += txt + '\n';
    }
    function keySort (d) {
        var keys = Object.keys (d).map (function f (x) { return parseFloat (x); });
        keys.sort (function f (a, b) { return a - b; });    // numerical sort
        return keys;
    }
    function img_out (str) {
        if (str.indexOf ('<svg') != -1) {
            str = str.replace (/width="(\d*)px"\s*height="(\d*)px"/, 'width="$1px" height="$2px" viewbox="0 0 $1 $2"');
            bxs = keySort (bxs), bys = keySort (bys);
            if (bxs.length > 1 &&   // the first barline is at bxs[1] because bxs[0] == left side staff
                bxs[1] < Math.min.apply (null, nxs)) {  // first barline < min x-coor of all notes in this line
                bxs.splice (0, 1);  // remove left side staff because there already is a left barline
            }
            bars.push ({ 'xs': bxs, 'ys': bys });
            bxs = {}, bys = {}, nxs = [];
        }
        muziek += str;
    }
    function svgInfo (type, s1, s2, x, y, w, h) {
        if (type == 'note' || type == 'rest') nxs.push (abc2svg.sx (x));  // x-coor of notes/rests for left barline check
        if (type == 'bar') {
            x = abc2svg.sx (x).toFixed (2);
            y = abc2svg.sy (y).toFixed (2);
            bxs [x] = 1, bys [y] = 1;
            xleft = abc2svg.sx (0).toFixed (2);
            bxs [xleft] = 1;
        }
    }
    function getTune (abctxt) {
        var ts, t, abc_lines, i, ro;
        abctxt = abctxt.replace (/\r\n/g,'\n'); // \r\n matches /^$/ ==> each line would get an extra empty line!!!
        ts = abctxt.split (/^\s*X:/m);  // split on X:, multi line search
        if (ts.length == 1) return [];  // no X:
        t = ts[1].split (/^\s*$/m);     // split on empty lines
        t = ts[0] + 'X:' + t[0];        // header + first tune
        abc_lines = t.split (/\r\n|[\n\r\u0085\u2028\u2029]/);  // whoppa
        for (i = 0; i < Math.min (100, abc_lines.length); ++i) {
            ro = abc_lines [i].match (/%%scale\s*([\d.]+)/);    // avoid %%scale 1.0, because different svg hierarchy
            if (ro && ro[1] == 1.0) abc_lines [i] = '%%scale 0.99';
        }
        return abc_lines;
    }
    function timeLine (ts_p, voice_tb, music_types) {
        var ts, g, ftempo = 384 * 120 / 60, dtmp, mdur = 0, mt = 0, nbeat, lbtm = 0;    // quarter duration 384, tempo 120
        try { nbeat = voice_tb [0].meter.a_meter [0].top; } // first voice, first meter: {top: x, bot: y}
        catch (e) { nbeat = '4'; }      // no meter defined in abc
        for (ts = ts_p; ts; ts = ts.ts_next) {
            if (ts.v != 0) continue;    // skip voices > 0
            switch (ts.type) {
            case TEMPO:
                dtmp = ts.tempo_notes.reduce (function (sum, x) { return sum + x; });
                ftempo = dtmp * ts.tempo / 60;
                break;
            case NOTE: case REST:
                mdur += ts.dur / ftempo;
                break;
            case BAR:
                //~ console.log ('bar_type: ' + ts.bar_type + ' text: ' + ts.text);
                if (ts.time == lbtm) { mreps [mreps.length - 1] += ts.bar_type; break; }    // concatenate left bar with previous
                if ('eoln' in ts) lbtm = ts.time;   // to detect left bar at start of line
                mdurs.push (mdur);
                mdur = 0;
                nbeat = nbeat.replace ('C|','2').replace ('C','4');
                mbeats.push (parseInt (nbeat));    // array of beats per measure
                mreps.push (ts.bar_type);
                mtxts.push (ts.text);
                break;
            case METER:
                nbeat = ts.a_meter [0].top;
                break;
            }
        }
    }
    function perc2map (abcIn) {
        var b = '%%beginsvg\n<defs>\n'
        b+= '<text id="x" x="-3" y="0">&#xe263;</text>\n'
        b+= '<text id="normal" x="-3.7" y="0">&#xe0a4;</text>\n'
        b+= '<g id="circle-x"><text x="-3" y="0">&#xe263;</text><circle r="4" class="stroke"/></g>\n'
        b+= '<path id="triangle" d="m-4 -3.2l4 6.4 4 -6.4z" class="stroke" style="stroke-width:1.4"/>\n'
        b+= '<path id="triangle+" d="m-4 -3.2l4 6.4 4 -6.4z" class="stroke" style="fill:#000"/>\n'
        b+= '<path id="rectangle" d="m-3.5 3l0 -6.2 7.2 0 0 6.2z" class="stroke" style="stroke-width:1.4"/>\n'
        b+= '<path id="rectangle+" d="m-3.5 3l0 -6.2 7.2 0 0 6.2z" class="stroke" style="fill:#000"/>\n'
        b+= '<path id="diamond" d="m0 -3l4.2 3.2 -4.2 3.2 -4.2 -3.2z" class="stroke" style="stroke-width:1.4"/>\n'
        b+= '<path id="diamond+" d="m0 -3l4.2 3.2 -4.2 3.2 -4.2 -3.2z" class="stroke" style="fill:#000"/>\n'
        b+= '</defs>\n%%endsvg'
        var fillmap = {'diamond':1, 'triangle':1, 'rectangle':1};
        var abc = [b], ls, i, x, r, id='default', maps = {'default':[]};
        ls = abcIn.split ('\n');
        for (i = 0; i < ls.length; ++i) {
            x = ls [i];
            if (x.indexOf ('I:percmap') >= 0) {
                x = x.split (' ');
                var kop = x[4];
                if (kop in fillmap) kop = kop + '+' + ',' + kop;
                x = '%%map perc'+id+ ' ' +x[1]+' print=' +x[2]+ ' midi=' +x[3]+ ' heads=' + kop;
                maps [id].push (x);
            }
            if (x.indexOf ('V:') >= 0) {
                r = x.match (/V:\s*(\S+)/);
                if (r) {
                    id = r[1];
                    if (!(id in maps)) maps [id] = [];
                }
            }
        }
        for (id in maps) abc = abc.concat (maps [id]);
        for (i = 0; i < ls.length; ++i) {
            x = ls [i];
            if (x.indexOf ('I:percmap') >= 0) continue;
            if (x.indexOf ('V:') >= 0 || x.indexOf ('K:') >= 0) {
                r = x.match (/V:\s*(\S+)/);
                if (r) id = r[1];
                if (maps [id].length == 0) id = 'default';
                abc.push (x);
                if (x.indexOf ('perc') >= 0 && x.indexOf ('map=') == -1) x += ' map=perc';
                if (x.indexOf ('map=perc') >= 0 && maps [id].length > 0) abc.push ('%%voicemap perc' + id);
                if (x.indexOf ('map=off') >= 0) abc.push ('%%voicemap');
            }
            else abc.push (x);
        }
        return abc.join ('\n');
    }
    function compPlayMap () {
        var line = 0, // (system) line index: 0..,
            ibar = 1,   // measure index on line: 1..
            nbars = bars [line].xs.length,  // number of measures on this line
            mix = 0,    // total measure index: mix = 0.., total time index: tix = 1..
            pbtime = 0, // play back time
            reptix = 1, // total time index of start of repeat    (count includes repeats)
            repmix = 0, // total measure index of start of repeat (count excludes repeats)
            repcnt = 1, // 2 in second traversal
            volta = 0,  // 1..
            repdone = {};   // mark executed repeats (for nested repeats)
        while (1) {
            var v = mtxts [mix-1];              // volta is on the previous measure
            var r = v ? v.match (/[,\d]*(\d)/) : null;  // last int is highest volta num
            if (r) {
                v = parseInt (r[1]);
                if (v != volta) volta = v;      // volta lasts until next volta
            }
            if (!volta || volta >= repcnt)      // skip when repcnt > volta num
            {
                pbtime += mdurs [mix];
                times.push (pbtime);
                tixbts.push (mbeats [mix]);     // also unfold beats for metronome and count-in
                if (!lbtix [line])       lbtix [line]       = [];
                if (!lbtix [line][ibar]) lbtix [line][ibar] = [];
                lbtix [line][ibar][repcnt] = tixlb.length;
                tixlb.push ([line, ibar, repcnt]);
            }
            if (mreps [mix] != '|') volta = 0;  // reset on any special bar line
            var r = /^:/.test (mreps [mix]);
            if (r && repcnt == 1 && !repdone [mix] && !opt.repskip) { // jump to start of repeat
                repcnt = 2;                     // now second play
                repdone [mix] = 1               // only execute repeats once (when nested)
                mix = repmix;
                ibar = tixlb [reptix][1];       // bar index on this line
                line = tixlb [reptix][0];       // line index
                nbars = bars [line].xs.length;  // number of measures on this line
            } else {
                if (r) repcnt = 1;              // reset repcount
                if (/:$/.test (mreps [mix])) {  // define start of repeat
                    reptix = tixlb.length;
                    repmix = mix + 1;
                    repcnt = 1;                 // first play
                }
                mix += 1;                       // go to next measure
                ibar += 1;
                if (ibar >= nbars) {            // measure is on next line
                    ibar = 1;                   // first bar index on this line
                    line += 1;                  // next line
                    if (line >= bars.length) break; // end of part
                    nbars = bars [line].xs.length;  // number of measures on this line
                }
            }
        }
    }
    initGlobals ();
    var score = $('#notation');
    $('body').attr ('title','') // clear drag/drop help message
    score.html ('');        // clear notation area
    var abc_lines = getTune (abctxt);
    abctxt = abc_lines.join ('\n');
    if (abctxt.indexOf ('percmap') >= 0) abctxt = perc2map (abctxt);
    var user = {
        'img_out': img_out,
        'errmsg': errmsg,
        'read_file': function (x) { return ''; },   // %%abc-include, unused
        'anno_start': svgInfo,
        'get_abcmodel': timeLine
    }
    abc2svg = new Abc (user);
    abc2svg.tosvg ('abc2svg', abctxt);
    if (errtxt != '') $('#err').append (errtxt);
    score.html (muziek);
    msc_svgs = score.find ('svg');  // all music lines
    msc_svgs.css ('overflow', 'visible');
    msc_svgs.children ('title').text ('');  // avoid title popup's
    var gs = msc_svgs.children ('g');   // only the topmost g per svg
    for (var i = 0; i < gs.length; ++i) {
        msc_gs.push (gs.eq (i));
    }
    var wz_xs = [], wz_ymin = [], wz_ymax = [];
    for (var i = 0; i < bars.length; ++i) { // i = line number
        var bs = bars [i];          // bars of line i
        wz_xs [i] = bs.xs;          // x coors of bars
        wz_ymin [i] = bs.ys [0];    // min, max y coor of bar
        wz_ymax [i] = bs.ys [bs.ys.length - 1];
    }
    compPlayMap ();
    //~ console.log ('times: ' + times);
    //~ console.log ('tixbts: ' + tixbts);
    //~ console.log ('mreps: ' + mreps);
    //~ console.log ('mtxts: ' + mtxts);
    //~ console.log ('tixlb: ' + JSON.stringify (tixlb));
    //~ console.log ('lbtix: ' + JSON.stringify (lbtix));
    //~ console.log ('len times: ' + times.length + ' len tixlb: ' + tixlb.length)
    if (typeof (times_arr) != 'undefined') {    // external timings take precedence.
        times = flattenTimes (times_arr);       // make 1d array of times
    }
    if (typeof (offset_js) != 'undefined') {
        offset = offset_js;     // external offset
    }
    if (typeof (endtime_js) != 'undefined') {   // scale times to given end time
        var durnew = endtime_js - offset;       // duration of score in seconds
        var durold = times [times.length - 1];  // first time is always 0
        times = times.map (function (t) { return t * durnew / durold });
    }
    abcSave = abc_lines;   // keep in global for saving
    msc_wz = new Wijzer (wz_xs, wz_ymin, wz_ymax, times, tixlb, lbtix, tixbts);
    msc_wz.setline (0);
    msc_svgs.each (function () { $(this).mousedown (klik); });  // each music line gets the click handler
    if (!elmed) elmed = dummyPlayer;
    var play_start = lpRec.loopStart + offset + TOFF;       // account for loopStart
    setTimeout (function () {                               // wait on DOM rendering ready (slow video!)
        playPause ('false:' + play_start + ':false', 0);    // position at start, no count_in, no delay
        setLoop ();
    }, 0);
}

function flattenTimes (times) {  // the number of measure per line may have changed since synchronization.
    var ts = times.map (function (x) { return x.slice (1); });      // cut begin times (doubles endtime prev line)
    ts = ts.reduce (function (acc, x) { return acc.concat (x); });  // glue all lines together -> [time_value]
    return ts;
}

function tick () {
    if (!elmed) return;
    var t = (yubchk ? elmed.getCurrentTime () : elmed.currentTime) - offset, tcur = t;
    if (t < 0) t = 0;
    if (opt.lopctl) {
        if (t > lpRec.loopEnd)   t = lpRec.loopStart;
        if (t < lpRec.loopStart) t = lpRec.loopStart + TOFF;
        if (t != tcur) yubchk ? elmed.seekTo (t + offset, true) : elmed.currentTime = t + offset;
    }
    if (msc_wz) msc_wz.time2x (t);
}

function klik (evt) {       // mousedown on svg
    evt.preventDefault ();
    evt.stopPropagation();
    var line = msc_svgs.get().indexOf (this);   // index of the clicked svg
    var x = evt.clientX;    // position click relative to page
    x -= $(this).position ().left;  // minus (position left edge if svg relative to page)
    msc_wz.x2time (x, line);
}

function syncChk () {
    $('#sync_out').css ('display', opt.synbox ? 'block' : 'none');
    if (msc_wz && opt.synbox) msc_wz.showSyncInfo ();
}

function btnChk () {
    toggleBtns ();  // -> setNotationHeight ()
    if (opt.btns && typeof (FileReader) == 'undefined') {
        $('#notation').prepend ('<h3>Your browser does not support reading of local files ...</h3>but you can use the preload feature.');
    }
}

function lineChk () {
    if (msc_wz) msc_wz.time2x (msc_wz.cursorTime);  // redraw cursor
    $('#notation').css ('text-align', opt.ctrnot ? 'center' : 'left');
}

function hideSpeedChk () {
    var spd = $('#spdctl').prop ('checked');    // show/hide speed
    $('#spdlbl').css ('display', spd ? 'block' : 'none');
}

function dropuse () {
    function grey (b) { $('#drpuse').prop ('checked',!b); $('#drpuse').attr ('disabled',b); $('#drplbl').css ('color',b?'#aaa':'#000'); }
    if (typeof (Dropbox) == 'undefined') {
        grey (true);
        var u = 'https://www.dropbox.com/static/api/2/dropins.js';
        $.ajax ({url: u, dataType: 'script', cache: true}).done (function () {
            grey (false);
            Dropbox.init ({appKey: 'ckknarypgq10318'});
            loaddrop ();
            dropuse ();
        });
    } else {
        var du = $('#drpuse').prop ('checked');
        $('.dropbox-dropin-btn').css ('display', du ? 'inline-block' : 'none');
        $('#fknp, #mknp').css ('display', du ? 'none' : 'inline-block');
    }
}

function toggleBtns () {
    $('#medbts').css ('display', opt.btns ? 'inline' : 'none');
    $('#err').css ('display', opt.btns ? 'block' : 'none');
    setNotationHeight ();
}
function metronome (tix, t) {
    var num, tik, dt, tb;
    clearInterval (in_count_in); in_count_in = 0;
    function telaf () {
        if (tik <= num) {
            in_count_in = setTimeout (telaf, dt);
            msc_wz.tiktak.text (tik);
            tik += 1;
        }
    }
    num = msc_wz.tixbts [tix - 1]; tik = 1;
    dt =  (msc_wz.times [tix] - t) / num / opt.speed * 1000;
    in_count_in = setTimeout (telaf, 0);
}
function clear_metronome () {
    if (!msc_wz) return;
    setTimeout (function () {   // use the event queue to avoid race condition with new telaf cycle
        clearInterval (in_count_in); in_count_in = 0; msc_wz.tiktak.text ('');
    }, 0);
}
var in_count_in = 0;    // timer id as semaphoor
function do_count_in (cmd, delay) {
    function reset () { $('#countin').toggle (false); clearInterval (in_count_in); in_count_in = 0; }
    function telaf () {
        $('#countin').html ('<b>' + ci.num + '</b>').toggle (true);
        if (ci.num-- == 0) { reset (); playPause (cmd, delay); };
    }
    if (in_count_in) { reset (); return; }
    cmd = cmd.replace (':true', ':false');  // reset count_in request
    var ci = msc_wz.compCountIn ();         // -> ci.time, ci.num
    telaf ();
    in_count_in = setInterval (telaf, ci.time * 1000);
}

function playPause (cmd, delay) {  // cmd = do_pause : at_time
    if (!elmed) return;
    var x = cmd.split (':'), toggle = x [0] == 'true', time = parseFloat (x [1]), fcount_in = x [2] == 'true';
    var yubstate = yubchk ? elmed.getPlayerState () : 0;
    var paused = yubchk ? yubstate != 1 : elmed.paused;
    yubchk ? yubstate != 5 && elmed.seekTo (time, true) : elmed.currentTime = time;  // always position (except when cued)
    if (paused && toggle || !paused && !toggle ) {  // play
        if (fcount_in)  {   // play after count in
            do_count_in (cmd, delay);
            return;
        }
        if (delay) {        // play after delay
            setTimeout  (function () { playPause (cmd, 0); }, delay);
            return;
        }
        yubchk ? elmed.playVideo () : elmed.play ();
        if (opt.metro && msc_wz) msc_wz.time_ix = 0; // to get the metronome running
    } else {    // pause
        yubchk ? yubstate != 5 && elmed.pauseVideo () : elmed.pause (); // do not pause when cued
        if (opt.metro) clear_metronome (); // clear metronome when paused
    }
    var rondaf = !opt.lncsr && !toggle;    // shading & only positioning & close to end bar -> correct bar time
    if (msc_wz) msc_wz.time2x (time - offset, rondaf);
}

function playPause2 (toggle, t) {   // toggle player state : go to t : with count in, only user actions come here
    var cmd = toggle + ':' + t.toFixed (2)  + ':' + (toggle && $('#cntin').prop ('checked'));
    if (sok) sok.send (cmd); else playPause (cmd, 0);   // synchronize when socket connection
}

function keyDown (e) {
    function toggleSpeedLoop () {
        if      (opt.spdctl && !opt.lopctl) $('#lopctl').click ();
        else if (opt.lopctl && !opt.spdctl) $('#spdctl').click ();
        else $('#spdctl, #lopctl').click ();
    }
    var key = e.keyCode ? e.keyCode : e.which;
    var done = 1;
    switch (key) {
    case 219: case 88: msc_wz.goMsre (0); break;    // [, x
    case 221: case 67: msc_wz.goMsre (1); break;    // ], c
    case 80: case 89: case 90:                      // p, z, y
        if (!elmed) break;
        playPause2 (true, yubchk ? elmed.getCurrentTime () : elmed.currentTime) // toggle player state
        break;
    case 65: $('#autscl').click (); break;          // a
    case 70: $('#btns').click (); break;            // f
    case 72: $('#help').toggleClass ('showhlp')     // h
    case 76: $('#lncsr').click (); break;           // l
    case 77: $('#menu label').toggle (); break;     // m
    case 83: toggleSpeedLoop (); break;             // s
    case 171: case 61: case 107: setSpeed (1); break;   // +, =, Num+
    case 173: case 109: setSpeed (-1); break;       // -, Num-
    default: done = 0; break;
    }
    if (!opt.synbox || !msc_wz || done) return;
    switch (key) {
    case 190: if (e.ctrlKey) { offset += gFac; } else msc_wz.changeTimesKeyb (gFac); break;  // ,
    case 188: if (e.ctrlKey) { offset -= gFac; } else msc_wz.changeTimesKeyb (-gFac); break; // .
    case 87: saveTiming (); break;                  // w
    }
    e.preventDefault ();    // our keys no default action
    msc_wz.showSyncInfo ();
}

function msc_resize () {
    centerPlayer ();
    if (!msc_wz) return;
    var w_svg = msc_svgs[0].width.baseVal.value;    // width svg element on screen (px)
    var force = w_svg > screen.width;               // only force with small devices
    if (!force && !opt.autscl) return;
    msc_wz.setSize.call (msc_wz);   // resize svg width to notation area width. Use msc_wz as "this".
    msc_wz.setScale.call (msc_wz);
}

function encMap (abc) {
    var xs = abc.map (function (x) {
        return window.btoa (unescape (encodeURIComponent (x)));
    }).join ('+');
    var ys = [], n = 0;
    while (n <= xs.length) { ys.push (xs.substr (n, 150)); n += 150; }
    return ys
}

function decMap (encabc) {
    return encabc.join ('').split ('+').map (function (x) {
        return decodeURIComponent (escape (window.atob (x)));
    }).join ('\n');
}

function saveTiming () {
    var a, ts, tss = [], fnm, of, res, tprev = '[', tlast, cdt, abcpln, abcenc, os, lpm;
    fnm = 'media_file = "' + (yubchk ? '' : mediaFnm) + '";\n'; // only when h5player active
    cdt = typeof (msc_credits) != 'undefined' ? 'msc_credits = ' + JSON.stringify (msc_credits) + ';\n': '';
    of = 'offset_js = ' + offset.toFixed (2) + ';\n';
    opt.synbox = 0; // do not save enable sync
    os = 'opt = ' + JSON.stringify (opt) + ';\n';
    opt.synbox = 1; // because we are still in sync mode
    lpm = lpRec.loopBtn ? 'lpRec = ' + JSON.stringify (lpRec) + ';\n' : '';
    ts = msc_wz.times.map (function (x) { return x.toFixed (2); })
    while (ts.length) { // make two dim array for backwards compatibility
        tlast = ts [9]; // duplicate the last element as the first of the next row
        tss.push (tprev + ts.splice (0, 10).join (',') + ']');
        tprev = '[' + tlast + ',';
    }
    ts = 'times_arr = [' + tss.join (',\n') + '];\n';
    if ($('#encr').prop ('checked')) {
        abcenc = encMap (abcSave).map (function f (x) { return JSON.stringify (x); });
        abcpln = ['"X:1"'];
    } else {
        abcenc = [''];
        abcpln = abcSave.map (function f (x) { return JSON.stringify (x); });
    }
    abcenc = 'abc_enc = [' + abcenc.join (',\n') + '];\n';
    abcpln = 'abc_arr = [' + abcpln.join (',\n') + '];\n';

    res =  '//########################################\n'
    res += '//# This page contains score data, timing data and the media file path. Save it as a text file in\n'
    res += '//# the same folder as abcweb.html. Abcweb preloads score and media when it is opened with the\n'
    res += '//# file name as parameter in the url, for example: http://your.domain.org/abcweb.html?file_name\n'
    res += '//# Also works locally with file:///path/to/abcweb.html?file_name\n'
    res += '//# **** You have to correct the path to the media file below! (media_file="...";) ****\n'
    res += '//########################################\n//#\n'
    res += fnm + cdt + of + os + lpm + ts + abcpln + abcenc;

    var dataUrl = 'data:text/plain;charset=utf-8;base64,' + btoa (unescape (encodeURIComponent (res)));
    if ($('#drpuse').prop ('checked')) {
        var options = {
            success: function () {
                $('#err').text ('"' + scoreFnm + '.js" saved to your Dropbox.\n');
            },
            progress: function (progress) {},
            cancel: function () {},
            error: function (errorMessage) {
                $('#err').text ("Error: " + errorMessage + '\n');
                $('#err').append ('fnm: ' + scoreFnm + ', len: ' + dataUrl.length + '\n');
            }
        };
        $('#err').text ('');
        Dropbox.save (dataUrl, scoreFnm + '.js', options);
    } else {
        try {
            a = document.createElement ('a');   // don't bother to use jquery
            a.href = dataUrl;
            a.download = scoreFnm + '.js';
            a.text = "Save synchronization data"
            $('#saveDiv').append (a); // append to a dummy invisible div
            a.click (); // only seems to work if a is appended somewhere in the body
        } catch (err) {
            if (!confirm ('Do you want to save your synchronization data?')) return;
            document.open ("text/html");    // clears the whole document and opens a new one
            document.write ('<pre>' + res + '</pre>');
            document.close ();
        }
    }
}

function msc_preload () {
    initPreload ();     // should run before preload
    $('#err').text ('');
    var parstr, xmlfnm = '', preload = '', elm, r, p, ps, i, m = '', host;
    parstr = window.location.href.replace ('?dl=0','').split ('?'); // look for parameters in the url;
    if (r = parstr [0].match (/:\/\/([^/:]+)/)) host = r [1];
    if (parstr.length > 1) {    // preload media and score
        ps = parstr [1].split ('&');
        for (i = 0; i < ps.length; i++) {
            p = ps [i].replace (/d:(\w{15}\/[^.]+\.)/, 'https://dl.dropboxusercontent.com/s/$1');
            if (r = p.match (/xml=(.*)/)) xmlfnm = decodeURIComponent (r [1]).replace ('www.dropbox', 'dl.dropboxusercontent');
            else if (r = p.match (/med=(.*)/)) m = r [1];
            else if (r = p.match (/tmr=(.*)/)) opt_url.top_margin = parseInt (r [1]);
            else if (r = p.match (/tb=([\d.]*)/)) offset_js = parseFloat (r [1]);
            else if (r = p.match (/te=([\d.]*)/)) endtime_js = parseFloat (r [1]);
            else if (r = p.match (/ip=(\d+.\d+.\d+.\d+)/)) opt_url.ipadr = r [1];
            else if (r = p.match (/^d([\d.]+)$/)) opt_url.delay = parseFloat (r[1]);
            else if (p.match (/ip=host/) && host) opt_url.ipadr = host;
            else if (p == 'mstr') opt_url.mstr = 1;
            else if (p == 'jmp') opt_url.jump = 1;
            else if (p == 'syn') opt_url.synbox = 1;
            else if (p == 'nb') opt_url.no_menu = 1;
            else if (p == 'sp') opt_url.spdctl = opt_url.lopctl = 1;
            else if (p == 'ur') opt_url.repufld = 1;
            else if (p == 'npl') opt_url.noplyr = 1;
            else if (p == 'ncr') opt_url.nocsr = 1;
            else if (p == 'asc') opt_url.autscl = 1;
            else if (p == 'cm') opt_url.ctrmed = 1;
            else if (p == 'cs') opt_url.ctrnot = 1;
            else if (p == 'nomed') { opt_url.nomed = 1; opt_url.noplyr = 1 }
            else preload = p;
            if (/(\.xml$)|(\.abc$)/.test (preload)) { xmlfnm = preload; preload = ''; }
            if (/(\.mp3$)|(\.mp4$)|(\.ogg$)|(\.webm$)/.test (preload)) { m = preload; preload = ''; }
        }
        if (m) {
            if (m.length == 11 && m.indexOf ('.') == -1) opt.yubvid = m;
            else media_file = decodeURIComponent (m).replace ('www.dropbox', 'dl.dropboxusercontent');
        }
        if (preload || xmlfnm) $('#wait').toggle (true);
        if (xmlfnm) {   // force loading xml as plain text
            $.get (xmlfnm, '', null, 'text').done (function (data, status) {
                $('#err').append ('preload: ' + status + '\n');
                abc_arr = data.split ('\n');
                msc_check_preload ();
            }).fail (function (jqxhr, settings, exception) {    // same origin policy
                $('#wait').append ('\npreload failed: ' + settings);
            });
        } else if (preload) {   // get the javasript preload file
            if (preload.indexOf ('dropbox.com') >= 0) preload += '?dl=1';
            $.getScript (preload).done (function (data, status) {
                $('#err').append ('preload: ' + status + '\n');
                msc_check_preload ();
            }).fail (function (jqxhr, settings, exception) {    // same origin policy, but ...
                $('#wait,#err').append ('preload failed: ' + exception + ', trying script tag ...\n');
                elm = document.createElement ('script');
                elm.src = preload;
                elm.onload = function () { msc_check_preload (); };
                elm.onerror = function () { $('#wait').append ('\npreload failed'); };
                document.head.appendChild (elm);    // execute cross domain javascript; security? what security?
                document.head.removeChild (elm);
            });

        }
    }
    return preload || xmlfnm;
}

function msc_check_preload () {
    if (typeof (abc_arr) != 'undefined') {
        var abc_string = abc_arr.join ('\n')
        if (typeof (abc_enc) != 'undefined' && abc_enc.length) {
            abc_string = decMap (abc_enc);
            opt.no_menu = 1;
        }
        readAbcOrXML (abc_string);  // always defined in preload -> starts another msc_check_preload after "eval ()" which redefines abc_arr;
    }
    for (var id in opt_url) opt [id] = opt_url [id];            // options in URL take precedence
    if ('nospd' in opt) {       // translate for backwards compatibility
        opt.spdctl = !opt.nospd;
        opt.nospd = undefined;  // avoid saving the old option
    }
    if (typeof (media_file) != 'undefined' && media_file && !opt.nomed) {
        setPlayer (media_file, media_file);
        opt.btns = 0;
    }
    if (opt.yubvid && !opt.nomed) { 
        setPlayer ('', '');
        opt.btns = 0;
    }
    if (typeof (msc_credits) != 'undefined') {
        var xs = msc_credits.reduce (function (acc, x) { return acc + x; });
        $('#credits').html (xs);
    }
    if (typeof (media_height) != 'undefined') opt.media_height = media_height;  // backwards compatibility (reset in initPreload)
    if (opt.no_menu) {
        $('#sync').css ('display', 'none'); // hide all buttons
        opt.btns = 0;   // when nb used as url parameter
        $('body').off ('dragenter dragleave drop dragover');
        $('body').on ('contextmenu', function (e) { e.preventDefault (); });
    }
    $('#wait').toggle (false);
    resetIntf (false);
}

function resetIntf (copy_options) {
    if (copy_options) for (var id in opt_url) opt [id] = opt_url [id];  // for url with only parameters
    if (opt.ipadr) webSokOpen (opt.ipadr);
    if (opt.media_height) $('#buttons').css ('height', opt.media_height);
    for (var id in opt) $('#' + id).prop ('checked', opt [id]); // set all checkboxes
    btnChk ();      // -> toggleBtns () -> setNotationHeight ()
    lineChk ();     // set lineCursor
    hideSpeedChk ();
    syncChk ();     // show sync_box+info when sync enabled
    msc_resize ();  // resize score when opt.autscl == true
    $('#sync, #medbts, #meddiv, #err').css ('visibility','visible');
}

function logerr (s) { $('#err').append (s + '\n'); }
function webSokOpen (ip) {
    if (sok) { logerr ('websocket already open');; return; }
    var url = 'ws://' + ip + ':' + 8091 + '/';
    sok = new WebSocket (url);
    sok.onmessage = function (event) {
        //~ logerr (event.data);
        if (event.data == 'master') $('#mbar').css ('background', 'rgba(255,0,0,0.2)');
        else playPause (event.data, opt.delay * 100);   // initial latency in 0.1 second units
    }
    sok.onerror   = function (event) { logerr ('socket error (server inaccessible?)');  sok = null; }
    sok.onopen    = function (event) { 
        $('#mbar').css ('background', 'rgba(0,255,0,0.2)');
        if (opt.mstr) sok.send ('master');
        logerr ('connection opened');
    }
    sok.onclose   = function (event) {
        $('#mbar').css ('background', '');
        logerr ('connection closed: ' + event.code); sok = null;
    }
}

function msc_shift (evt) {
    if (hideMenuHelp ()) return;
    if (evt.target.id != 'meddiv') return;
    $('#buttons').css ('opacity','0.5');
    $('#streep').css ('opacity','1.0');
    var touchDev = evt.type == 'touchstart';
    var doel = $('#meddiv');
    var y1 = touchDev ? evt.originalEvent.touches[0].clientY : evt.pageY;
    var bh = $('#buttons').height ();
    doel.css ('cursor', 'row-resize')
    doel.on ('mousemove touchmove', function (evt) {
        var h = $('body').height ();
        var y2 = touchDev ? evt.originalEvent.touches[0].clientY : evt.pageY;
        var y = bh + y2 - y1;
        var p = 100 * y / h;    // height percentage
        opt.media_height = p.toFixed () + '%'
        $('#buttons').css ('height', opt.media_height);
    });
    doel.on ('mouseup touchend', function (evt) {
        $('#buttons').css ('opacity','1.0');
        $('#streep').css ('opacity','0.0');
        doel.off ('mousemove touchmove mouseup touchend');
        doel.css ('cursor', 'initial')
        setNotationHeight ();
    });
}

function setSpeed (inc) {
    if (inc == 2) {     // response to change event
        var newspeed = $('#speed').val ();
        var dif = newspeed - opt.speed;
        if (Math.abs (dif) <= 0.06) inc = dif > 0 ? 1 : -1; // probably step-up/down
        else { opt.speed = newspeed; inc = 0; }             // probably manual setting
    }
    var ix = pbrates    // get the index of the playback rate closest to opt.speed
        .map  (function (x,i) { return {x: Math.abs (x - opt.speed), i:i}; })
        .sort (function (a,b) { return a.x - b.x; }) [0].i;
    if (inc == -1 && ix > 0)                  opt.speed = pbrates [ix + inc];
    if (inc == 1  && ix < pbrates.length - 1) opt.speed = pbrates [ix + inc];
    if (inc == 0) opt.speed = pbrates [ix];
    $('#speed').val (opt.speed.toFixed (2));
    if (elmed && !yubchk) elmed.playbackRate = opt.speed;
    if (elmed && yubchk) elmed.setPlaybackRate (opt.speed);
}

function setLoop () {
    if (msc_wz) msc_wz.drawTags ();
    opt.lopctl = $('#lopctl').prop ('checked');
    $('#atag').css ('display', opt.lopctl ? 'block' : 'none');
    $('#btag').css ('display', opt.lopctl ? 'block' : 'none');
}

function loaddrop () {
    var dknp1 = Dropbox.createChooseButton ({
        success: readDbxFile,
        cancel: function() {}, linkType: "direct", multiselect: false,
        extensions: ['.xml', '.abc', '.txt', '.js']
    });
    var dknp2 = Dropbox.createChooseButton ({
        success: function (farr) { readMedia ('dbx', farr); },
        cancel: function() {}, linkType: "preview", multiselect: false,
        extensions:  ['.ogg', '.mp3', '.webm', '.mp4']
    });
    $('#abcfile').append (dknp1);
    $('#mediafile').append (dknp2);
}

function checkMenu (evt) {
    var chk = $(this).prop ('checked');
    var id = $(this).attr ('id');
    opt [id] = chk;  // update the option object
    switch (id) {
    case 'ctrnot': lineChk (); break;
    case 'ctrmed': centerPlayer (); break;
    case 'spdctl': hideSpeedChk (); break;
    case 'autscl': msc_resize (); break;
    case 'lncsr': lineChk (); break;
    case 'btns': btnChk (); break
    case 'synbox': syncChk (); break;
    case 'noplyr': setNotationHeight (); break;
    case 'nocsr': if (msc_wz && !dummyPlayer.paused) msc_wz.noCursor = chk; break; // immediately hide/show while playing
    case 'metro': if (!chk) clear_metronome ();
    }
}

function hideMenu () {
    $('#menu label').css ('display', 'none');
}
function hideMenuHelp () {          // called from click event dispatcher -> the change event could come later
    var b = $('#menu label').css ('display') != 'none' || $('#help').hasClass ('showhlp');
    if (b) {
        $('#help').toggleClass ('showhlp', false);
        setTimeout (hideMenu, 0);   // wait until menu change event is dispatched -> doReadPdf = 1
    }
    return b
}

$(document).ready (function () {
    $('#drpuse').prop ('checked', false);
    if (!msc_preload ()) { resetIntf (true); }
    $(window).resize (msc_resize);  // only event handlers follow (and one time DOM changes)
    $('body').keydown (keyDown);
    $('#save').click (saveTiming);
    $('#speed').change (function () { setSpeed (2); });
    $('#lopctl').click (setLoop);
    var vtxt = '<a href="http://wim.vree.org/js/">abcweb</a> (version: ' + msc_VERSION + ')</br>¬©Willem Vree'
    vtxt += '<br>using:<br><a href="http://moinejf.free.fr/js/">abc2svg</a>, ¬©Jef Moine'
    $('#help').prepend ('<div style="position: absolute; right: 5px;">' + vtxt + '</div>');
    $('#helpm').click (function () { $('#help').toggleClass ('showhlp'); });
    $('#meddiv').on ('mousedown touchstart', msc_shift);
    $('#fknp').change (function () { readLocalFile ('btn', []); });
    $('#mknp').change (function () { readMedia ('btn', []); });
    $('#yknp').click (readMediaYub);
    $('#yubid').keydown (function (e) { e.stopPropagation (); });   // prevent bubble up to shortcut actions
    $('#yubuse').change (medbtnSwitch);
    $('#drpuse').click (dropuse);
    $('#notation').mousedown (function () {
        if (hideMenuHelp ()) return;
        keyDown ({'keyCode':80});
    });
    $('#jump').change (checkMenu);
    $('#impbox').change (toggleScoreBtn);
    $('#menu * input').change (checkMenu);      // for all menu checkboxes
    $('#menu label').toggle ();                 // hide all menu items
    $('#mbar').click (function () {
        if ($('#menu label').css ('display') == 'none') $('#menu label').toggle (true);
        else hideMenu ();
    });
    $('#woff').change (function () { noprogress = $(this).prop ('checked'); });
    $.event.props.push ( "dataTransfer" );          // make jQuery copy the dataTransfer attribute
    $('body').on ('drop', doDrop);
    $('body').on ('dragover', function (e) {   // this handler makes the element accept drops and generate drop-events
        e.stopPropagation (); e.preventDefault ();  // the preventDefault is obligatory for drag/drop!
        e.dataTransfer.dropEffect = 'copy';         // show a plus sign to indicate the file is copied
    });
    $('body').on ('dragenter dragleave', function () { $(this).toggleClass ('indrag'); });
});
})();
